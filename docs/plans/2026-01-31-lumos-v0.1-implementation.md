# Lumos v0.1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a minimal Windows tray app that adjusts monitor gamma with crash-safe restoration.

**Architecture:** Win32 window hosts ImGui UI, platform layer isolates Windows APIs (gamma, tray), app layer coordinates state. DirectX 11 backend for ImGui rendering.

**Tech Stack:** C++20, Win32 API, DirectX 11, ImGui (git submodule), CMake 3.20+

---

## Task 1: Project Scaffolding

**Files:**

- Create: `CMakeLists.txt`
- Create: `src/main.cpp`
- Create: `third_party/imgui/CMakeLists.txt`
- Create: `resources/lumos.rc`

**Step 1: Add ImGui as git submodule**

Run:

```bash
git submodule add https://github.com/ocornut/imgui.git third_party/imgui
```

**Step 2: Create ImGui CMake wrapper**

Create `third_party/imgui/CMakeLists.txt`:

```cmake
add_library(imgui STATIC
    imgui.cpp
    imgui_demo.cpp
    imgui_draw.cpp
    imgui_tables.cpp
    imgui_widgets.cpp
    backends/imgui_impl_win32.cpp
    backends/imgui_impl_dx11.cpp
)

target_include_directories(imgui PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}/backends
)

target_link_libraries(imgui PUBLIC d3d11 dxgi)
```

**Step 3: Create root CMakeLists.txt**

Create `CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Create minimal main.cpp**

Create `src/main.cpp`:

```cpp
// Lumos - Monitor gamma adjustment utility
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow)
{
    (void)hInstance;
    (void)hPrevInstance;
    (void)lpCmdLine;
    (void)nCmdShow;

    MessageBoxW(nullptr, L"Lumos v0.1 - Scaffolding works!", L"Lumos", MB_OK);
    return 0;
}
```

**Step 5: Create resource file**

Create `resources/lumos.rc`:

```rc
// Lumos Windows resources
#include <windows.h>

// Version info
VS_VERSION_INFO VERSIONINFO
FILEVERSION     0,1,0,0
PRODUCTVERSION  0,1,0,0
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "FileDescription", "Lumos - Monitor Gamma Utility"
            VALUE "FileVersion", "0.1.0"
            VALUE "ProductName", "Lumos"
            VALUE "ProductVersion", "0.1.0"
            VALUE "LegalCopyright", "GPL v2"
        END
    END
END
```

**Step 6: Create directory structure**

Run:

```bash
mkdir -p src/platform/win32 src/ui resources
```

**Step 7: Commit scaffolding**

Run:

```bash
git add CMakeLists.txt src/main.cpp third_party/imgui resources/lumos.rc
git commit -m "feat: add project scaffolding with CMake and ImGui submodule"
```

---

## Task 2: GitHub Actions CI

**Files:**

- Create: `.github/workflows/build.yml`

**Step 1: Create workflow file**

Create `.github/workflows/build.yml`:

```yaml
name: Build

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1

      - name: Configure CMake
        run: cmake -B build -G "Visual Studio 17 2022" -A x64

      - name: Build
        run: cmake --build build --config Release

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: lumos-windows-x64
          path: build/Release/lumos.exe
```

**Step 2: Commit workflow**

Run:

```bash
mkdir -p .github/workflows
git add .github/workflows/build.yml
git commit -m "ci: add GitHub Actions build workflow"
```

---

## Task 3: Win32 Window + DirectX 11 Setup

**Files:**

- Modify: `src/main.cpp`

**Step 1: Implement Win32 window with DX11**

Replace `src/main.cpp` with:

```cpp
// Lumos - Monitor gamma adjustment utility
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <d3d11.h>
#include <dxgi.h>

#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx11.h"

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Globals for DX11
static ID3D11Device* g_pd3dDevice = nullptr;
static ID3D11DeviceContext* g_pd3dDeviceContext = nullptr;
static IDXGISwapChain* g_pSwapChain = nullptr;
static ID3D11RenderTargetView* g_mainRenderTargetView = nullptr;

// Forward declarations
bool CreateDeviceD3D(HWND hWnd);
void CleanupDeviceD3D();
void CreateRenderTarget();
void CleanupRenderTarget();
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow)
{
    (void)hPrevInstance;
    (void)lpCmdLine;
    (void)nCmdShow;

    // Register window class
    WNDCLASSEXW wc = {};
    wc.cbSize = sizeof(WNDCLASSEXW);
    wc.style = CS_CLASSDC;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"LumosWindowClass";
    RegisterClassExW(&wc);

    // Create window
    HWND hwnd = CreateWindowExW(
        0,
        wc.lpszClassName,
        L"Lumos",
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT,
        400, 200,
        nullptr, nullptr, hInstance, nullptr);

    if (!CreateDeviceD3D(hwnd))
    {
        CleanupDeviceD3D();
        UnregisterClassW(wc.lpszClassName, hInstance);
        return 1;
    }

    ShowWindow(hwnd, SW_SHOWDEFAULT);
    UpdateWindow(hwnd);

    // Setup ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

    ImGui::StyleColorsDark();

    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Main loop
    bool running = true;
    while (running)
    {
        MSG msg;
        while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
            if (msg.message == WM_QUIT)
                running = false;
        }
        if (!running)
            break;

        // Start ImGui frame
        ImGui_ImplDX11_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();

        // Simple test window
        ImGui::SetNextWindowPos(ImVec2(10, 10), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSize(ImVec2(370, 150), ImGuiCond_FirstUseEver);
        ImGui::Begin("Lumos", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse);
        ImGui::Text("Gamma adjustment utility");
        ImGui::Text("Window + DX11 + ImGui working!");
        ImGui::End();

        // Render
        ImGui::Render();
        const float clear_color[4] = { 0.1f, 0.1f, 0.1f, 1.0f };
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, nullptr);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color);
        ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

        g_pSwapChain->Present(1, 0); // VSync
    }

    // Cleanup
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    DestroyWindow(hwnd);
    UnregisterClassW(wc.lpszClassName, hInstance);

    return 0;
}

bool CreateDeviceD3D(HWND hWnd)
{
    DXGI_SWAP_CHAIN_DESC sd = {};
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0 };

    HRESULT res = D3D11CreateDeviceAndSwapChain(
        nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr,
        createDeviceFlags, featureLevelArray, 2,
        D3D11_SDK_VERSION, &sd,
        &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);

    if (res != S_OK)
        return false;

    CreateRenderTarget();
    return true;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = nullptr; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = nullptr; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
}

void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer = nullptr;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = nullptr; }
}

LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_SIZE:
        if (g_pd3dDevice != nullptr && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hWnd, msg, wParam, lParam);
}
```

**Step 2: Commit DX11 + ImGui integration**

Run:

```bash
git add src/main.cpp
git commit -m "feat: add Win32 window with DirectX 11 and ImGui"
```

---

## Task 4: Gamma Platform Module

**Files:**

- Create: `src/platform/win32/gamma.h`
- Create: `src/platform/win32/gamma.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create gamma.h**

Create `src/platform/win32/gamma.h`:

```cpp
// Lumos - Gamma control module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <array>

namespace lumos::platform {

struct GammaRamp {
    std::array<WORD, 256> red;
    std::array<WORD, 256> green;
    std::array<WORD, 256> blue;
};

class Gamma {
public:
    Gamma() = default;
    ~Gamma();

    // Capture current gamma ramp (call on startup)
    bool captureOriginal();

    // Restore saved gamma ramp
    bool restoreOriginal();

    // Apply gamma value (0.1 - 9.0, 1.0 = normal)
    bool apply(double value);

    // Read current gamma from primary display
    double read() const;

    // Check if we have a captured original
    bool hasOriginal() const { return has_original_; }

private:
    GammaRamp original_ramp_{};
    bool has_original_ = false;
};

} // namespace lumos::platform
```

**Step 2: Create gamma.cpp**

Create `src/platform/win32/gamma.cpp`:

```cpp
// Lumos - Gamma control module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "gamma.h"
#include <cmath>

namespace lumos::platform {

Gamma::~Gamma()
{
    // Best-effort restore on destruction
    if (has_original_) {
        restoreOriginal();
    }
}

bool Gamma::captureOriginal()
{
    HDC hdc = GetDC(nullptr);
    if (!hdc) return false;

    BOOL result = GetDeviceGammaRamp(hdc, &original_ramp_);
    ReleaseDC(nullptr, hdc);

    if (result) {
        has_original_ = true;
    }
    return result != FALSE;
}

bool Gamma::restoreOriginal()
{
    if (!has_original_) return false;

    HDC hdc = GetDC(nullptr);
    if (!hdc) return false;

    BOOL result = SetDeviceGammaRamp(hdc, &original_ramp_);
    ReleaseDC(nullptr, hdc);

    return result != FALSE;
}

bool Gamma::apply(double value)
{
    // Clamp to valid range
    if (value < 0.1) value = 0.1;
    if (value > 9.0) value = 9.0;

    // Build gamma ramp
    GammaRamp ramp{};
    for (int i = 0; i < 256; ++i) {
        double normalized = i / 255.0;
        double corrected = std::pow(normalized, 1.0 / value);
        WORD val = static_cast<WORD>(corrected * 65535.0);

        ramp.red[i] = val;
        ramp.green[i] = val;
        ramp.blue[i] = val;
    }

    HDC hdc = GetDC(nullptr);
    if (!hdc) return false;

    BOOL result = SetDeviceGammaRamp(hdc, &ramp);
    ReleaseDC(nullptr, hdc);

    return result != FALSE;
}

double Gamma::read() const
{
    HDC hdc = GetDC(nullptr);
    if (!hdc) return 1.0;

    GammaRamp ramp{};
    BOOL result = GetDeviceGammaRamp(hdc, &ramp);
    ReleaseDC(nullptr, hdc);

    if (!result) return 1.0;

    // Sample middle value to estimate gamma
    // Using index 128 (middle of ramp)
    double normalized_in = 128.0 / 255.0;  // 0.502
    double normalized_out = ramp.red[128] / 65535.0;

    // Avoid log(0) or invalid values
    if (normalized_out <= 0.0 || normalized_out >= 1.0) {
        return 1.0;
    }

    // gamma = 1 / (log(out) / log(in))
    // out = in^(1/gamma)
    // log(out) = (1/gamma) * log(in)
    // gamma = log(in) / log(out)
    double gamma = std::log(normalized_in) / std::log(normalized_out);

    // Clamp to reasonable range
    if (gamma < 0.1) gamma = 0.1;
    if (gamma > 9.0) gamma = 9.0;

    return gamma;
}

} // namespace lumos::platform
```

**Step 3: Update CMakeLists.txt**

Modify `CMakeLists.txt` to add gamma source:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/platform/win32/gamma.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Commit gamma module**

Run:

```bash
git add src/platform/win32/gamma.h src/platform/win32/gamma.cpp CMakeLists.txt
git commit -m "feat: add gamma control platform module"
```

---

## Task 5: System Tray Module

**Files:**

- Create: `src/platform/win32/tray.h`
- Create: `src/platform/win32/tray.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create tray.h**

Create `src/platform/win32/tray.h`:

```cpp
// Lumos - System tray module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <shellapi.h>
#include <functional>

namespace lumos::platform {

class Tray {
public:
    Tray() = default;
    ~Tray();

    // Initialize tray icon
    bool create(HWND parent, UINT callback_msg);

    // Remove tray icon
    void destroy();

    // Show context menu at cursor position
    void showMenu();

    // Handle tray callback message, returns true if handled
    bool handleMessage(WPARAM wParam, LPARAM lParam);

    // Menu item callbacks
    std::function<void()> on_open;
    std::function<void()> on_reset;
    std::function<void()> on_exit;

    // Menu item IDs
    static constexpr UINT ID_OPEN = 1001;
    static constexpr UINT ID_RESET = 1002;
    static constexpr UINT ID_EXIT = 1003;

private:
    HWND hwnd_ = nullptr;
    UINT callback_msg_ = 0;
    bool created_ = false;
    NOTIFYICONDATAW nid_{};
};

} // namespace lumos::platform
```

**Step 2: Create tray.cpp**

Create `src/platform/win32/tray.cpp`:

```cpp
// Lumos - System tray module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "tray.h"

namespace lumos::platform {

Tray::~Tray()
{
    destroy();
}

bool Tray::create(HWND parent, UINT callback_msg)
{
    if (created_) return true;

    hwnd_ = parent;
    callback_msg_ = callback_msg;

    nid_.cbSize = sizeof(NOTIFYICONDATAW);
    nid_.hWnd = hwnd_;
    nid_.uID = 1;
    nid_.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    nid_.uCallbackMessage = callback_msg_;
    nid_.hIcon = LoadIconW(nullptr, IDI_APPLICATION); // Default icon for now
    wcscpy_s(nid_.szTip, L"Lumos - Gamma Control");

    if (!Shell_NotifyIconW(NIM_ADD, &nid_)) {
        return false;
    }

    created_ = true;
    return true;
}

void Tray::destroy()
{
    if (!created_) return;

    Shell_NotifyIconW(NIM_DELETE, &nid_);
    created_ = false;
}

void Tray::showMenu()
{
    POINT pt;
    GetCursorPos(&pt);

    HMENU menu = CreatePopupMenu();
    if (!menu) return;

    AppendMenuW(menu, MF_STRING, ID_OPEN, L"Open Lumos");
    AppendMenuW(menu, MF_SEPARATOR, 0, nullptr);
    AppendMenuW(menu, MF_STRING, ID_RESET, L"Reset Gamma");
    AppendMenuW(menu, MF_SEPARATOR, 0, nullptr);
    AppendMenuW(menu, MF_STRING, ID_EXIT, L"Exit");

    // Required for menu to work properly from tray
    SetForegroundWindow(hwnd_);

    UINT cmd = TrackPopupMenu(
        menu,
        TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
        pt.x, pt.y,
        0, hwnd_, nullptr);

    DestroyMenu(menu);

    // Handle selection
    switch (cmd) {
    case ID_OPEN:
        if (on_open) on_open();
        break;
    case ID_RESET:
        if (on_reset) on_reset();
        break;
    case ID_EXIT:
        if (on_exit) on_exit();
        break;
    }

    // Required for menu to dismiss properly
    PostMessageW(hwnd_, WM_NULL, 0, 0);
}

bool Tray::handleMessage(WPARAM wParam, LPARAM lParam)
{
    (void)wParam;

    switch (LOWORD(lParam)) {
    case WM_RBUTTONUP:
        showMenu();
        return true;
    case WM_LBUTTONDBLCLK:
        if (on_open) on_open();
        return true;
    }

    return false;
}

} // namespace lumos::platform
```

**Step 3: Update CMakeLists.txt**

Modify `CMakeLists.txt` to add tray source:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/platform/win32/gamma.cpp
    src/platform/win32/tray.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Commit tray module**

Run:

```bash
git add src/platform/win32/tray.h src/platform/win32/tray.cpp CMakeLists.txt
git commit -m "feat: add system tray platform module"
```

---

## Task 6: Config Module

**Files:**

- Create: `src/config.h`
- Create: `src/config.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create config.h**

Create `src/config.h`:

```cpp
// Lumos - Configuration module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#include <string>
#include <filesystem>

namespace lumos {

class Config {
public:
    Config() = default;

    // Load config from file (creates default if missing)
    bool load();

    // Save config to file
    bool save();

    // Settings
    double last_gamma = 1.0;

private:
    std::filesystem::path getConfigDir();
    std::filesystem::path getConfigPath();
};

} // namespace lumos
```

**Step 2: Create config.cpp**

Create `src/config.cpp`:

```cpp
// Lumos - Configuration module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "config.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <shlobj.h>
#include <fstream>
#include <string>

namespace lumos {

std::filesystem::path Config::getConfigDir()
{
    wchar_t* path = nullptr;
    if (SUCCEEDED(SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &path))) {
        std::filesystem::path result = path;
        CoTaskMemFree(path);
        return result / L"Lumos";
    }
    return std::filesystem::path{};
}

std::filesystem::path Config::getConfigPath()
{
    return getConfigDir() / L"lumos.ini";
}

bool Config::load()
{
    auto config_path = getConfigPath();
    if (!std::filesystem::exists(config_path)) {
        // Create default config
        return save();
    }

    std::ifstream file(config_path);
    if (!file.is_open()) return false;

    std::string line;
    while (std::getline(file, line)) {
        // Simple INI parsing
        if (line.starts_with("LastValue=")) {
            try {
                last_gamma = std::stod(line.substr(10));
                if (last_gamma < 0.1) last_gamma = 0.1;
                if (last_gamma > 9.0) last_gamma = 9.0;
            } catch (...) {
                last_gamma = 1.0;
            }
        }
    }

    return true;
}

bool Config::save()
{
    auto config_dir = getConfigDir();
    if (config_dir.empty()) return false;

    // Create directory if needed
    std::filesystem::create_directories(config_dir);

    auto config_path = getConfigPath();
    std::ofstream file(config_path);
    if (!file.is_open()) return false;

    file << "[Gamma]\n";
    file << "LastValue=" << last_gamma << "\n";

    return true;
}

} // namespace lumos
```

**Step 3: Update CMakeLists.txt**

Modify `CMakeLists.txt` to add config source:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/config.cpp
    src/platform/win32/gamma.cpp
    src/platform/win32/tray.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Commit config module**

Run:

```bash
git add src/config.h src/config.cpp CMakeLists.txt
git commit -m "feat: add configuration module with INI persistence"
```

---

## Task 7: App Orchestration Layer

**Files:**

- Create: `src/app.h`
- Create: `src/app.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create app.h**

Create `src/app.h`:

```cpp
// Lumos - Application orchestration
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#include "config.h"
#include "platform/win32/gamma.h"
#include "platform/win32/tray.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

namespace lumos {

class App {
public:
    App() = default;

    // Initialize application (call after window creation)
    bool initialize(HWND hwnd, UINT tray_msg);

    // Shutdown application (call before exit)
    void shutdown();

    // Set gamma value (applies immediately)
    void setGamma(double value);

    // Reset to original gamma
    void resetGamma();

    // Get current gamma value
    double getGamma() const { return current_gamma_; }

    // Window visibility
    void showWindow();
    void hideWindow();
    bool isWindowVisible() const { return window_visible_; }

    // Request application exit
    void requestExit();
    bool shouldExit() const { return should_exit_; }

    // Handle tray messages
    bool handleTrayMessage(WPARAM wParam, LPARAM lParam);

    // Get status text for UI
    const char* getStatusText() const { return status_text_; }

private:
    Config config_;
    platform::Gamma gamma_;
    platform::Tray tray_;

    HWND hwnd_ = nullptr;
    double current_gamma_ = 1.0;
    bool window_visible_ = true;
    bool should_exit_ = false;
    char status_text_[64] = "Ready";
};

} // namespace lumos
```

**Step 2: Create app.cpp**

Create `src/app.cpp`:

```cpp
// Lumos - Application orchestration
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "app.h"
#include <cstdio>

namespace lumos {

bool App::initialize(HWND hwnd, UINT tray_msg)
{
    hwnd_ = hwnd;

    // Load config
    config_.load();
    current_gamma_ = config_.last_gamma;

    // Capture original gamma for restoration
    if (!gamma_.captureOriginal()) {
        std::snprintf(status_text_, sizeof(status_text_), "Warning: Could not capture original gamma");
    }

    // Apply saved gamma
    if (current_gamma_ != 1.0) {
        gamma_.apply(current_gamma_);
    }

    // Create tray icon
    if (!tray_.create(hwnd_, tray_msg)) {
        std::snprintf(status_text_, sizeof(status_text_), "Warning: Could not create tray icon");
    }

    // Set up tray callbacks
    tray_.on_open = [this]() { showWindow(); };
    tray_.on_reset = [this]() { resetGamma(); };
    tray_.on_exit = [this]() { requestExit(); };

    std::snprintf(status_text_, sizeof(status_text_), "Applied to primary display");
    return true;
}

void App::shutdown()
{
    // Save config
    config_.last_gamma = current_gamma_;
    config_.save();

    // Restore original gamma
    gamma_.restoreOriginal();

    // Remove tray icon
    tray_.destroy();
}

void App::setGamma(double value)
{
    if (value < 0.1) value = 0.1;
    if (value > 9.0) value = 9.0;

    current_gamma_ = value;

    if (gamma_.apply(value)) {
        std::snprintf(status_text_, sizeof(status_text_), "Applied to primary display");
    } else {
        std::snprintf(status_text_, sizeof(status_text_), "Failed to apply gamma");
    }
}

void App::resetGamma()
{
    current_gamma_ = 1.0;

    if (gamma_.restoreOriginal()) {
        std::snprintf(status_text_, sizeof(status_text_), "Reset to original");
    } else {
        // Fall back to setting gamma to 1.0
        gamma_.apply(1.0);
        std::snprintf(status_text_, sizeof(status_text_), "Reset to default (1.0)");
    }
}

void App::showWindow()
{
    if (hwnd_) {
        ShowWindow(hwnd_, SW_SHOW);
        SetForegroundWindow(hwnd_);
    }
    window_visible_ = true;
}

void App::hideWindow()
{
    if (hwnd_) {
        ShowWindow(hwnd_, SW_HIDE);
    }
    window_visible_ = false;
}

void App::requestExit()
{
    should_exit_ = true;
    if (hwnd_) {
        PostMessageW(hwnd_, WM_CLOSE, 0, 0);
    }
}

bool App::handleTrayMessage(WPARAM wParam, LPARAM lParam)
{
    return tray_.handleMessage(wParam, lParam);
}

} // namespace lumos
```

**Step 3: Update CMakeLists.txt**

Modify `CMakeLists.txt` to add app source:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/app.cpp
    src/config.cpp
    src/platform/win32/gamma.cpp
    src/platform/win32/tray.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Commit app module**

Run:

```bash
git add src/app.h src/app.cpp CMakeLists.txt
git commit -m "feat: add app orchestration layer"
```

---

## Task 8: ImGui UI Window

**Files:**

- Create: `src/ui/main_window.h`
- Create: `src/ui/main_window.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create main_window.h**

Create `src/ui/main_window.h`:

```cpp
// Lumos - Main UI window
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

namespace lumos {
class App;
}

namespace lumos::ui {

class MainWindow {
public:
    MainWindow() = default;

    // Render the window (call each frame)
    void render(App& app);

private:
    float gamma_slider_ = 1.0f;
    bool first_frame_ = true;
};

} // namespace lumos::ui
```

**Step 2: Create main_window.cpp**

Create `src/ui/main_window.cpp`:

```cpp
// Lumos - Main UI window
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "main_window.h"
#include "../app.h"
#include "imgui.h"

namespace lumos::ui {

void MainWindow::render(App& app)
{
    // Sync slider with app state on first frame
    if (first_frame_) {
        gamma_slider_ = static_cast<float>(app.getGamma());
        first_frame_ = false;
    }

    // Full window ImGui panel
    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(viewport->Pos);
    ImGui::SetNextWindowSize(viewport->Size);

    ImGuiWindowFlags flags =
        ImGuiWindowFlags_NoTitleBar |
        ImGuiWindowFlags_NoResize |
        ImGuiWindowFlags_NoMove |
        ImGuiWindowFlags_NoCollapse |
        ImGuiWindowFlags_NoBringToFrontOnFocus;

    ImGui::Begin("##MainWindow", nullptr, flags);

    // Title
    ImGui::TextUnformatted("Lumos - Gamma Control");
    ImGui::Separator();
    ImGui::Spacing();

    // Gamma slider
    ImGui::TextUnformatted("Gamma");
    ImGui::SetNextItemWidth(-1);
    if (ImGui::SliderFloat("##Gamma", &gamma_slider_, 0.1f, 9.0f, "%.2f")) {
        app.setGamma(static_cast<double>(gamma_slider_));
    }

    ImGui::Spacing();

    // Current value display
    ImGui::Text("Current: %.2f", gamma_slider_);

    ImGui::Spacing();
    ImGui::Spacing();

    // Reset button
    if (ImGui::Button("Reset to Default", ImVec2(-1, 0))) {
        app.resetGamma();
        gamma_slider_ = static_cast<float>(app.getGamma());
    }

    // Status at bottom
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::TextDisabled("%s", app.getStatusText());

    ImGui::End();
}

} // namespace lumos::ui
```

**Step 3: Update CMakeLists.txt**

Modify `CMakeLists.txt` to add ui source:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/app.cpp
    src/config.cpp
    src/platform/win32/gamma.cpp
    src/platform/win32/tray.cpp
    src/ui/main_window.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 4: Commit UI module**

Run:

```bash
git add src/ui/main_window.h src/ui/main_window.cpp CMakeLists.txt
git commit -m "feat: add ImGui main window UI"
```

---

## Task 9: Integrate All Modules into main.cpp

**Files:**

- Modify: `src/main.cpp`

**Step 1: Update main.cpp with full integration**

Replace `src/main.cpp` with:

```cpp
// Lumos - Monitor gamma adjustment utility
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <d3d11.h>
#include <dxgi.h>

#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx11.h"

#include "app.h"
#include "ui/main_window.h"

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Custom window messages
constexpr UINT WM_TRAYICON = WM_USER + 1;

// Globals for DX11
static ID3D11Device* g_pd3dDevice = nullptr;
static ID3D11DeviceContext* g_pd3dDeviceContext = nullptr;
static IDXGISwapChain* g_pSwapChain = nullptr;
static ID3D11RenderTargetView* g_mainRenderTargetView = nullptr;

// Global app instance for WndProc access
static lumos::App* g_app = nullptr;

// Forward declarations
bool CreateDeviceD3D(HWND hWnd);
void CleanupDeviceD3D();
void CreateRenderTarget();
void CleanupRenderTarget();
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow)
{
    (void)hPrevInstance;
    (void)lpCmdLine;
    (void)nCmdShow;

    // Register window class
    WNDCLASSEXW wc = {};
    wc.cbSize = sizeof(WNDCLASSEXW);
    wc.style = CS_CLASSDC;
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"LumosWindowClass";
    wc.hIcon = LoadIconW(nullptr, IDI_APPLICATION);
    RegisterClassExW(&wc);

    // Create window
    HWND hwnd = CreateWindowExW(
        0,
        wc.lpszClassName,
        L"Lumos",
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT,
        400, 200,
        nullptr, nullptr, hInstance, nullptr);

    if (!CreateDeviceD3D(hwnd))
    {
        CleanupDeviceD3D();
        UnregisterClassW(wc.lpszClassName, hInstance);
        return 1;
    }

    // Setup ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    io.IniFilename = nullptr; // Disable imgui.ini

    ImGui::StyleColorsDark();

    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Initialize app
    lumos::App app;
    g_app = &app;
    app.initialize(hwnd, WM_TRAYICON);

    // UI
    lumos::ui::MainWindow main_window;

    // Show window
    ShowWindow(hwnd, SW_SHOWDEFAULT);
    UpdateWindow(hwnd);

    // Main loop
    while (!app.shouldExit())
    {
        MSG msg;
        while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
            if (msg.message == WM_QUIT) {
                app.requestExit();
            }
        }

        if (app.shouldExit())
            break;

        // Skip rendering if window is hidden
        if (!app.isWindowVisible()) {
            Sleep(100); // Reduce CPU usage when hidden
            continue;
        }

        // Start ImGui frame
        ImGui_ImplDX11_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();

        // Render UI
        main_window.render(app);

        // Render
        ImGui::Render();
        const float clear_color[4] = { 0.1f, 0.1f, 0.1f, 1.0f };
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, nullptr);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color);
        ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

        g_pSwapChain->Present(1, 0); // VSync
    }

    // Shutdown
    app.shutdown();
    g_app = nullptr;

    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    DestroyWindow(hwnd);
    UnregisterClassW(wc.lpszClassName, hInstance);

    return 0;
}

bool CreateDeviceD3D(HWND hWnd)
{
    DXGI_SWAP_CHAIN_DESC sd = {};
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0 };

    HRESULT res = D3D11CreateDeviceAndSwapChain(
        nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr,
        createDeviceFlags, featureLevelArray, 2,
        D3D11_SDK_VERSION, &sd,
        &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext);

    if (res != S_OK)
        return false;

    CreateRenderTarget();
    return true;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = nullptr; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = nullptr; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = nullptr; }
}

void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer = nullptr;
    g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, nullptr, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = nullptr; }
}

LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_TRAYICON:
        if (g_app) {
            g_app->handleTrayMessage(wParam, lParam);
        }
        return 0;

    case WM_SIZE:
        if (g_pd3dDevice != nullptr && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;

    case WM_SYSCOMMAND:
        // Minimize to tray instead of taskbar
        if ((wParam & 0xfff0) == SC_MINIMIZE) {
            if (g_app) {
                g_app->hideWindow();
            }
            return 0;
        }
        break;

    case WM_CLOSE:
        // Hide to tray instead of closing (unless exit requested)
        if (g_app && !g_app->shouldExit()) {
            g_app->hideWindow();
            return 0;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }

    return DefWindowProcW(hWnd, msg, wParam, lParam);
}
```

**Step 2: Commit full integration**

Run:

```bash
git add src/main.cpp
git commit -m "feat: integrate all modules into main application loop"
```

---

## Task 10: Crash Safety

**Files:**

- Modify: `src/main.cpp`

**Step 1: Add crash handlers at start of WinMain**

In `src/main.cpp`, add crash safety after the includes and before WinMain:

Add this code block after the global declarations and before `int WINAPI WinMain`:

```cpp
// Crash safety - restore gamma on unhandled exception
static lumos::platform::Gamma* g_crash_gamma = nullptr;

LONG WINAPI CrashHandler(EXCEPTION_POINTERS* exceptionInfo)
{
    (void)exceptionInfo;
    if (g_crash_gamma) {
        g_crash_gamma->restoreOriginal();
    }
    return EXCEPTION_EXECUTE_HANDLER;
}
```

Then at the start of WinMain, after the unused parameter casts, add:

```cpp
    // Set up crash handler
    SetUnhandledExceptionFilter(CrashHandler);
```

And after `app.initialize(hwnd, WM_TRAYICON);` add:

```cpp
    // Enable crash safety
    g_crash_gamma = &app.getGammaRef();
```

**Step 2: Add getGammaRef to App class**

In `src/app.h`, add to the public section:

```cpp
    // Get reference to gamma module (for crash handler)
    platform::Gamma& getGammaRef() { return gamma_; }
```

**Step 3: Commit crash safety**

Run:

```bash
git add src/main.cpp src/app.h
git commit -m "feat: add crash safety handler to restore gamma"
```

---

## Task 11: Final Testing & Push

**Step 1: Verify all files exist**

Run:

```bash
ls -la src/
ls -la src/platform/win32/
ls -la src/ui/
```

**Step 2: Push to GitHub**

Run:

```bash
git push -u origin main
```

**Step 3: Verify GitHub Actions runs**

Check https://github.com/IanDirkArmstrong/lumos/actions for build status.

---

## Summary

After completing all tasks, you will have:

- **v0.1 complete**: Tray app with gamma slider, reset, hide-to-tray, crash safety
- **Modular architecture**: Clean separation of platform/ui/app layers
- **CI/CD ready**: GitHub Actions builds on every push
- **Config persistence**: Last gamma value saved to `%APPDATA%\Lumos\lumos.ini`

**Next milestone (v0.2)** will add:

- Global hotkeys
- Multi-monitor support
- CLI interface
