# Lumos v0.2 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add power-user features: global hotkeys, multi-monitor support, CLI interface, and About/Help dialogs.

**Prerequisites:** v0.1 complete (tray app with gamma slider, config persistence, crash safety)

**Tech Stack:** C++20, Win32 API, DirectX 11, ImGui, CMake 3.20+

---

## Task 1: Global Hotkeys Platform Module

**Files:**

- Create: `src/platform/win32/hotkeys.h`
- Create: `src/platform/win32/hotkeys.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create hotkeys.h**

Create `src/platform/win32/hotkeys.h`:

```cpp
// Lumos - Global hotkeys module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <functional>

namespace lumos::platform {

class Hotkeys {
public:
    Hotkeys() = default;
    ~Hotkeys();

    // Initialize hotkeys (call after window creation)
    bool initialize(HWND hwnd);

    // Cleanup hotkeys
    void shutdown();

    // Handle WM_HOTKEY message, returns true if handled
    bool handleMessage(WPARAM wParam);

    // Callbacks
    std::function<void()> on_increase;
    std::function<void()> on_decrease;
    std::function<void()> on_reset;

    // Hotkey IDs
    static constexpr int ID_INCREASE = 1;
    static constexpr int ID_DECREASE = 2;
    static constexpr int ID_RESET = 3;

    // Default key bindings
    static constexpr UINT MOD_KEYS = MOD_CONTROL | MOD_ALT;
    static constexpr UINT VK_INCREASE = VK_UP;      // Ctrl+Alt+Up
    static constexpr UINT VK_DECREASE = VK_DOWN;    // Ctrl+Alt+Down
    static constexpr UINT VK_RESET_KEY = 'R';       // Ctrl+Alt+R

private:
    HWND hwnd_ = nullptr;
    bool registered_ = false;
};

} // namespace lumos::platform
```

**Step 2: Create hotkeys.cpp**

Create `src/platform/win32/hotkeys.cpp`:

```cpp
// Lumos - Global hotkeys module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "hotkeys.h"

namespace lumos::platform {

Hotkeys::~Hotkeys()
{
    shutdown();
}

bool Hotkeys::initialize(HWND hwnd)
{
    if (registered_) return true;

    hwnd_ = hwnd;

    // Register global hotkeys
    bool success = true;

    if (!RegisterHotKey(hwnd_, ID_INCREASE, MOD_KEYS | MOD_NOREPEAT, VK_INCREASE)) {
        success = false;
    }

    if (!RegisterHotKey(hwnd_, ID_DECREASE, MOD_KEYS | MOD_NOREPEAT, VK_DECREASE)) {
        success = false;
    }

    if (!RegisterHotKey(hwnd_, ID_RESET, MOD_KEYS | MOD_NOREPEAT, VK_RESET_KEY)) {
        success = false;
    }

    registered_ = true;
    return success;
}

void Hotkeys::shutdown()
{
    if (!registered_ || !hwnd_) return;

    UnregisterHotKey(hwnd_, ID_INCREASE);
    UnregisterHotKey(hwnd_, ID_DECREASE);
    UnregisterHotKey(hwnd_, ID_RESET);

    registered_ = false;
}

bool Hotkeys::handleMessage(WPARAM wParam)
{
    switch (wParam) {
    case ID_INCREASE:
        if (on_increase) on_increase();
        return true;
    case ID_DECREASE:
        if (on_decrease) on_decrease();
        return true;
    case ID_RESET:
        if (on_reset) on_reset();
        return true;
    }
    return false;
}

} // namespace lumos::platform
```

**Step 3: Update CMakeLists.txt**

Add `src/platform/win32/hotkeys.cpp` to the executable sources.

**Step 4: Commit hotkeys module**

Run:

```bash
git add src/platform/win32/hotkeys.h src/platform/win32/hotkeys.cpp CMakeLists.txt
git commit -m "feat: add global hotkeys platform module"
```

---

## Task 2: Multi-Monitor Support in Gamma Module

**Files:**

- Modify: `src/platform/win32/gamma.h`
- Modify: `src/platform/win32/gamma.cpp`

**Step 1: Update gamma.h with multi-monitor support**

Replace `src/platform/win32/gamma.h`:

```cpp
// Lumos - Gamma control module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <array>
#include <vector>
#include <string>

namespace lumos::platform {

struct GammaRamp {
    std::array<WORD, 256> red;
    std::array<WORD, 256> green;
    std::array<WORD, 256> blue;
};

struct MonitorInfo {
    HMONITOR handle;
    std::wstring device_name;
    std::wstring friendly_name;
    bool is_primary;
    GammaRamp original_ramp;
    bool has_original;
};

class Gamma {
public:
    Gamma() = default;
    ~Gamma();

    // Enumerate monitors and capture original ramps
    bool initialize();

    // Restore all original gamma ramps
    bool restoreAll();

    // Apply gamma value to all monitors
    bool applyAll(double value);

    // Apply gamma value to specific monitor
    bool apply(size_t monitor_index, double value);

    // Restore specific monitor
    bool restore(size_t monitor_index);

    // Get monitor count
    size_t getMonitorCount() const { return monitors_.size(); }

    // Get monitor info
    const MonitorInfo* getMonitor(size_t index) const;

    // Get primary monitor index
    size_t getPrimaryIndex() const;

    // Legacy single-monitor interface (operates on primary)
    bool captureOriginal();
    bool restoreOriginal();
    bool apply(double value);
    double read() const;
    bool hasOriginal() const;

private:
    std::vector<MonitorInfo> monitors_;

    static BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor,
                                          LPRECT lprcMonitor, LPARAM dwData);

    bool captureRamp(MonitorInfo& monitor);
    bool applyRamp(const MonitorInfo& monitor, const GammaRamp& ramp);
    static GammaRamp buildRamp(double gamma);
};

} // namespace lumos::platform
```

**Step 2: Update gamma.cpp with multi-monitor support**

Replace `src/platform/win32/gamma.cpp`:

```cpp
// Lumos - Gamma control module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "gamma.h"
#include <cmath>

namespace lumos::platform {

Gamma::~Gamma()
{
    restoreAll();
}

BOOL CALLBACK Gamma::MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor,
                                      LPRECT lprcMonitor, LPARAM dwData)
{
    (void)hdcMonitor;
    (void)lprcMonitor;

    auto* monitors = reinterpret_cast<std::vector<MonitorInfo>*>(dwData);

    MONITORINFOEXW mi = {};
    mi.cbSize = sizeof(mi);
    if (!GetMonitorInfoW(hMonitor, &mi)) {
        return TRUE; // Continue enumeration
    }

    MonitorInfo info = {};
    info.handle = hMonitor;
    info.device_name = mi.szDevice;
    info.friendly_name = mi.szDevice; // TODO: Get friendly name from registry
    info.is_primary = (mi.dwFlags & MONITORINFOF_PRIMARY) != 0;
    info.has_original = false;

    monitors->push_back(info);
    return TRUE;
}

bool Gamma::initialize()
{
    monitors_.clear();

    // Enumerate all monitors
    EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc,
                        reinterpret_cast<LPARAM>(&monitors_));

    if (monitors_.empty()) {
        return false;
    }

    // Capture original ramps for all monitors
    bool success = true;
    for (auto& monitor : monitors_) {
        if (!captureRamp(monitor)) {
            success = false;
        }
    }

    return success;
}

bool Gamma::captureRamp(MonitorInfo& monitor)
{
    HDC hdc = CreateDCW(L"DISPLAY", monitor.device_name.c_str(), nullptr, nullptr);
    if (!hdc) return false;

    BOOL result = GetDeviceGammaRamp(hdc, &monitor.original_ramp);
    DeleteDC(hdc);

    if (result) {
        monitor.has_original = true;
    }
    return result != FALSE;
}

bool Gamma::applyRamp(const MonitorInfo& monitor, const GammaRamp& ramp)
{
    HDC hdc = CreateDCW(L"DISPLAY", monitor.device_name.c_str(), nullptr, nullptr);
    if (!hdc) return false;

    // Need non-const for SetDeviceGammaRamp
    GammaRamp ramp_copy = ramp;
    BOOL result = SetDeviceGammaRamp(hdc, &ramp_copy);
    DeleteDC(hdc);

    return result != FALSE;
}

GammaRamp Gamma::buildRamp(double gamma)
{
    if (gamma < 0.1) gamma = 0.1;
    if (gamma > 9.0) gamma = 9.0;

    GammaRamp ramp{};
    for (int i = 0; i < 256; ++i) {
        double normalized = i / 255.0;
        double corrected = std::pow(normalized, 1.0 / gamma);
        WORD val = static_cast<WORD>(corrected * 65535.0);

        ramp.red[i] = val;
        ramp.green[i] = val;
        ramp.blue[i] = val;
    }
    return ramp;
}

bool Gamma::restoreAll()
{
    bool success = true;
    for (const auto& monitor : monitors_) {
        if (monitor.has_original) {
            if (!applyRamp(monitor, monitor.original_ramp)) {
                success = false;
            }
        }
    }
    return success;
}

bool Gamma::applyAll(double value)
{
    GammaRamp ramp = buildRamp(value);
    bool success = true;
    for (const auto& monitor : monitors_) {
        if (!applyRamp(monitor, ramp)) {
            success = false;
        }
    }
    return success;
}

bool Gamma::apply(size_t monitor_index, double value)
{
    if (monitor_index >= monitors_.size()) return false;

    GammaRamp ramp = buildRamp(value);
    return applyRamp(monitors_[monitor_index], ramp);
}

bool Gamma::restore(size_t monitor_index)
{
    if (monitor_index >= monitors_.size()) return false;

    const auto& monitor = monitors_[monitor_index];
    if (!monitor.has_original) return false;

    return applyRamp(monitor, monitor.original_ramp);
}

const MonitorInfo* Gamma::getMonitor(size_t index) const
{
    if (index >= monitors_.size()) return nullptr;
    return &monitors_[index];
}

size_t Gamma::getPrimaryIndex() const
{
    for (size_t i = 0; i < monitors_.size(); ++i) {
        if (monitors_[i].is_primary) return i;
    }
    return 0; // Fallback to first monitor
}

// Legacy single-monitor interface
bool Gamma::captureOriginal()
{
    return initialize();
}

bool Gamma::restoreOriginal()
{
    return restoreAll();
}

bool Gamma::apply(double value)
{
    return applyAll(value);
}

double Gamma::read() const
{
    if (monitors_.empty()) return 1.0;

    size_t primary = getPrimaryIndex();
    const auto& monitor = monitors_[primary];

    HDC hdc = CreateDCW(L"DISPLAY", monitor.device_name.c_str(), nullptr, nullptr);
    if (!hdc) return 1.0;

    GammaRamp ramp{};
    BOOL result = GetDeviceGammaRamp(hdc, &ramp);
    DeleteDC(hdc);

    if (!result) return 1.0;

    // Sample middle value to estimate gamma
    double normalized_in = 128.0 / 255.0;
    double normalized_out = ramp.red[128] / 65535.0;

    if (normalized_out <= 0.0 || normalized_out >= 1.0) {
        return 1.0;
    }

    double gamma = std::log(normalized_in) / std::log(normalized_out);

    if (gamma < 0.1) gamma = 0.1;
    if (gamma > 9.0) gamma = 9.0;

    return gamma;
}

bool Gamma::hasOriginal() const
{
    for (const auto& monitor : monitors_) {
        if (monitor.has_original) return true;
    }
    return false;
}

} // namespace lumos::platform
```

**Step 3: Commit multi-monitor support**

Run:

```bash
git add src/platform/win32/gamma.h src/platform/win32/gamma.cpp
git commit -m "feat: add multi-monitor support to gamma module"
```

---

## Task 3: CLI Argument Parsing

**Files:**

- Create: `src/cli.h`
- Create: `src/cli.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create cli.h**

Create `src/cli.h`:

```cpp
// Lumos - Command line interface
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#include <optional>
#include <string>

namespace lumos {

enum class CliAction {
    ShowGui,        // No args or invalid args: launch GUI
    SetGamma,       // Numeric arg: set gamma and exit
    ShowHelp,       // --help: show usage
    ShowVersion     // --version: show version
};

struct CliArgs {
    CliAction action = CliAction::ShowGui;
    double gamma_value = 1.0;
};

class Cli {
public:
    // Parse command line arguments
    static CliArgs parse(int argc, char* argv[]);
    static CliArgs parse(const wchar_t* cmdLine);

    // Print help to stdout (requires console)
    static void printHelp();

    // Print version to stdout (requires console)
    static void printVersion();

private:
    static std::optional<double> parseGammaValue(const std::string& str);
};

} // namespace lumos
```

**Step 2: Create cli.cpp**

Create `src/cli.cpp`:

```cpp
// Lumos - Command line interface
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "cli.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <shellapi.h>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <vector>

namespace lumos {

std::optional<double> Cli::parseGammaValue(const std::string& str)
{
    try {
        size_t pos = 0;
        double value = std::stod(str, &pos);

        // Ensure entire string was consumed
        if (pos != str.length()) {
            return std::nullopt;
        }

        // Validate range
        if (value < 0.1 || value > 9.0) {
            return std::nullopt;
        }

        return value;
    } catch (...) {
        return std::nullopt;
    }
}

CliArgs Cli::parse(int argc, char* argv[])
{
    CliArgs args;

    if (argc < 2) {
        args.action = CliAction::ShowGui;
        return args;
    }

    std::string arg1 = argv[1];

    if (arg1 == "--help" || arg1 == "-h") {
        args.action = CliAction::ShowHelp;
        return args;
    }

    if (arg1 == "--version" || arg1 == "-v") {
        args.action = CliAction::ShowVersion;
        return args;
    }

    // Try to parse as gamma value
    auto gamma = parseGammaValue(arg1);
    if (gamma.has_value()) {
        args.action = CliAction::SetGamma;
        args.gamma_value = gamma.value();
        return args;
    }

    // Unknown argument, show GUI
    args.action = CliAction::ShowGui;
    return args;
}

CliArgs Cli::parse(const wchar_t* cmdLine)
{
    int argc = 0;
    wchar_t** argv = CommandLineToArgvW(cmdLine, &argc);

    if (!argv || argc < 2) {
        if (argv) LocalFree(argv);
        return CliArgs{};
    }

    // Convert first argument to narrow string
    std::string arg1;
    int len = WideCharToMultiByte(CP_UTF8, 0, argv[1], -1, nullptr, 0, nullptr, nullptr);
    if (len > 0) {
        arg1.resize(len - 1);
        WideCharToMultiByte(CP_UTF8, 0, argv[1], -1, arg1.data(), len, nullptr, nullptr);
    }

    LocalFree(argv);

    // Parse using string version
    const char* args[] = { "lumos", arg1.c_str() };
    return parse(2, const_cast<char**>(args));
}

void Cli::printHelp()
{
    // Attach to parent console if available
    if (AttachConsole(ATTACH_PARENT_PROCESS)) {
        FILE* fp = nullptr;
        freopen_s(&fp, "CONOUT$", "w", stdout);
    }

    std::printf("\nLumos - Monitor Gamma Adjustment Utility\n\n");
    std::printf("Usage:\n");
    std::printf("  lumos              Open the GUI\n");
    std::printf("  lumos <value>      Set gamma (0.1-9.0) and exit\n");
    std::printf("  lumos --help       Show this help message\n");
    std::printf("  lumos --version    Show version information\n");
    std::printf("\n");
    std::printf("Hotkeys (when running):\n");
    std::printf("  Ctrl+Alt+Up        Increase gamma by 0.1\n");
    std::printf("  Ctrl+Alt+Down      Decrease gamma by 0.1\n");
    std::printf("  Ctrl+Alt+R         Reset to default (1.0)\n");
    std::printf("\n");
    std::printf("Examples:\n");
    std::printf("  lumos 1.2          Set gamma to 1.2\n");
    std::printf("  lumos 0.8          Set gamma to 0.8\n");
    std::printf("\n");
}

void Cli::printVersion()
{
    if (AttachConsole(ATTACH_PARENT_PROCESS)) {
        FILE* fp = nullptr;
        freopen_s(&fp, "CONOUT$", "w", stdout);
    }

    std::printf("\nLumos v0.2.0\n");
    std::printf("Copyright (C) 2026 Ian Dirk Armstrong\n");
    std::printf("License: GPL v2\n\n");
}

} // namespace lumos
```

**Step 3: Update CMakeLists.txt**

Add `src/cli.cpp` to the executable sources.

**Step 4: Commit CLI module**

Run:

```bash
git add src/cli.h src/cli.cpp CMakeLists.txt
git commit -m "feat: add command line interface module"
```

---

## Task 4: Integrate Hotkeys into App

**Files:**

- Modify: `src/app.h`
- Modify: `src/app.cpp`

**Step 1: Update app.h**

Add hotkeys member and methods to `src/app.h`:

```cpp
// Lumos - Application orchestration
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#include "config.h"
#include "platform/win32/gamma.h"
#include "platform/win32/tray.h"
#include "platform/win32/hotkeys.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

namespace lumos {

class App {
public:
    App() = default;

    // Initialize application (call after window creation)
    bool initialize(HWND hwnd, UINT tray_msg);

    // Shutdown application (call before exit)
    void shutdown();

    // Set gamma value (applies immediately to all monitors)
    void setGamma(double value);

    // Adjust gamma by delta
    void adjustGamma(double delta);

    // Reset to original gamma
    void resetGamma();

    // Get current gamma value
    double getGamma() const { return current_gamma_; }

    // Window visibility
    void showWindow();
    void hideWindow();
    bool isWindowVisible() const { return window_visible_; }

    // Request application exit
    void requestExit();
    bool shouldExit() const { return should_exit_; }

    // Handle tray messages
    bool handleTrayMessage(WPARAM wParam, LPARAM lParam);

    // Handle hotkey messages
    bool handleHotkeyMessage(WPARAM wParam);

    // Get status text for UI
    const char* getStatusText() const { return status_text_; }

    // Get monitor count
    size_t getMonitorCount() const { return gamma_.getMonitorCount(); }

    // Get reference to gamma module (for crash handler)
    platform::Gamma& getGammaRef() { return gamma_; }

private:
    Config config_;
    platform::Gamma gamma_;
    platform::Tray tray_;
    platform::Hotkeys hotkeys_;

    HWND hwnd_ = nullptr;
    double current_gamma_ = 1.0;
    bool window_visible_ = true;
    bool should_exit_ = false;
    char status_text_[64] = "Ready";

    static constexpr double GAMMA_STEP = 0.1;
};

} // namespace lumos
```

**Step 2: Update app.cpp**

Add hotkey handling to `src/app.cpp`:

```cpp
// Lumos - Application orchestration
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "app.h"
#include <cstdio>
#include <algorithm>

namespace lumos {

bool App::initialize(HWND hwnd, UINT tray_msg)
{
    hwnd_ = hwnd;

    // Load config
    config_.load();
    current_gamma_ = config_.last_gamma;

    // Initialize gamma (captures original ramps for all monitors)
    if (!gamma_.initialize()) {
        std::snprintf(status_text_, sizeof(status_text_), "Warning: Could not initialize gamma");
    }

    // Apply saved gamma to all monitors
    if (current_gamma_ != 1.0) {
        gamma_.applyAll(current_gamma_);
    }

    // Create tray icon
    if (!tray_.create(hwnd_, tray_msg)) {
        std::snprintf(status_text_, sizeof(status_text_), "Warning: Could not create tray icon");
    }

    // Set up tray callbacks
    tray_.on_open = [this]() { showWindow(); };
    tray_.on_reset = [this]() { resetGamma(); };
    tray_.on_exit = [this]() { requestExit(); };

    // Initialize hotkeys
    if (!hotkeys_.initialize(hwnd_)) {
        std::snprintf(status_text_, sizeof(status_text_), "Warning: Some hotkeys failed to register");
    }

    // Set up hotkey callbacks
    hotkeys_.on_increase = [this]() { adjustGamma(GAMMA_STEP); };
    hotkeys_.on_decrease = [this]() { adjustGamma(-GAMMA_STEP); };
    hotkeys_.on_reset = [this]() { resetGamma(); };

    size_t count = gamma_.getMonitorCount();
    std::snprintf(status_text_, sizeof(status_text_), "Applied to %zu display%s",
                  count, count == 1 ? "" : "s");
    return true;
}

void App::shutdown()
{
    // Shutdown hotkeys
    hotkeys_.shutdown();

    // Save config
    config_.last_gamma = current_gamma_;
    config_.save();

    // Restore original gamma on all monitors
    gamma_.restoreAll();

    // Remove tray icon
    tray_.destroy();
}

void App::setGamma(double value)
{
    value = std::clamp(value, 0.1, 9.0);
    current_gamma_ = value;

    if (gamma_.applyAll(value)) {
        size_t count = gamma_.getMonitorCount();
        std::snprintf(status_text_, sizeof(status_text_), "Applied to %zu display%s",
                      count, count == 1 ? "" : "s");
    } else {
        std::snprintf(status_text_, sizeof(status_text_), "Failed to apply gamma");
    }
}

void App::adjustGamma(double delta)
{
    setGamma(current_gamma_ + delta);
}

void App::resetGamma()
{
    current_gamma_ = 1.0;

    if (gamma_.restoreAll()) {
        std::snprintf(status_text_, sizeof(status_text_), "Reset to original");
    } else {
        gamma_.applyAll(1.0);
        std::snprintf(status_text_, sizeof(status_text_), "Reset to default (1.0)");
    }
}

void App::showWindow()
{
    if (hwnd_) {
        ShowWindow(hwnd_, SW_SHOW);
        SetForegroundWindow(hwnd_);
    }
    window_visible_ = true;
}

void App::hideWindow()
{
    if (hwnd_) {
        ShowWindow(hwnd_, SW_HIDE);
    }
    window_visible_ = false;
}

void App::requestExit()
{
    should_exit_ = true;
    if (hwnd_) {
        PostMessageW(hwnd_, WM_CLOSE, 0, 0);
    }
}

bool App::handleTrayMessage(WPARAM wParam, LPARAM lParam)
{
    return tray_.handleMessage(wParam, lParam);
}

bool App::handleHotkeyMessage(WPARAM wParam)
{
    return hotkeys_.handleMessage(wParam);
}

} // namespace lumos
```

**Step 3: Commit app integration**

Run:

```bash
git add src/app.h src/app.cpp
git commit -m "feat: integrate hotkeys and multi-monitor into app layer"
```

---

## Task 5: Update Config for Hotkey Bindings

**Files:**

- Modify: `src/config.h`
- Modify: `src/config.cpp`

**Step 1: Update config.h**

Add hotkey settings to `src/config.h`:

```cpp
// Lumos - Configuration module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

#include <string>
#include <filesystem>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

namespace lumos {

struct HotkeyBinding {
    UINT modifiers = MOD_CONTROL | MOD_ALT;
    UINT key = 0;
};

class Config {
public:
    Config() = default;

    // Load config from file (creates default if missing)
    bool load();

    // Save config to file
    bool save();

    // Settings
    double last_gamma = 1.0;

    // Hotkey bindings
    HotkeyBinding hotkey_increase = { MOD_CONTROL | MOD_ALT, VK_UP };
    HotkeyBinding hotkey_decrease = { MOD_CONTROL | MOD_ALT, VK_DOWN };
    HotkeyBinding hotkey_reset = { MOD_CONTROL | MOD_ALT, 'R' };

private:
    std::filesystem::path getConfigDir();
    std::filesystem::path getConfigPath();
};

} // namespace lumos
```

**Step 2: Update config.cpp**

Add hotkey parsing to `src/config.cpp`:

```cpp
// Lumos - Configuration module
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "config.h"

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <shlobj.h>
#include <fstream>
#include <string>

namespace lumos {

std::filesystem::path Config::getConfigDir()
{
    wchar_t* path = nullptr;
    if (SUCCEEDED(SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &path))) {
        std::filesystem::path result = path;
        CoTaskMemFree(path);
        return result / L"Lumos";
    }
    return std::filesystem::path{};
}

std::filesystem::path Config::getConfigPath()
{
    return getConfigDir() / L"lumos.ini";
}

bool Config::load()
{
    auto config_path = getConfigPath();
    if (!std::filesystem::exists(config_path)) {
        return save();
    }

    std::ifstream file(config_path);
    if (!file.is_open()) return false;

    std::string line;
    while (std::getline(file, line)) {
        if (line.starts_with("LastValue=")) {
            try {
                last_gamma = std::stod(line.substr(10));
                if (last_gamma < 0.1) last_gamma = 0.1;
                if (last_gamma > 9.0) last_gamma = 9.0;
            } catch (...) {
                last_gamma = 1.0;
            }
        }
        // TODO: Parse hotkey bindings in future version
    }

    return true;
}

bool Config::save()
{
    auto config_dir = getConfigDir();
    if (config_dir.empty()) return false;

    std::filesystem::create_directories(config_dir);

    auto config_path = getConfigPath();
    std::ofstream file(config_path);
    if (!file.is_open()) return false;

    file << "[Gamma]\n";
    file << "LastValue=" << last_gamma << "\n";
    file << "\n";
    file << "[Hotkeys]\n";
    file << "; Hotkey customization coming in v1.0\n";
    file << "; Defaults: Ctrl+Alt+Up (increase), Ctrl+Alt+Down (decrease), Ctrl+Alt+R (reset)\n";

    return true;
}

} // namespace lumos
```

**Step 3: Commit config updates**

Run:

```bash
git add src/config.h src/config.cpp
git commit -m "feat: add hotkey binding placeholders to config"
```

---

## Task 6: Update UI to Show Monitor Count

**Files:**

- Modify: `src/ui/main_window.cpp`

**Step 1: Update main_window.cpp**

Update status display in `src/ui/main_window.cpp`:

```cpp
// Lumos - Main UI window
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "main_window.h"
#include "../app.h"
#include "imgui.h"

namespace lumos::ui {

void MainWindow::render(App& app)
{
    // Sync slider with app state on first frame
    if (first_frame_) {
        gamma_slider_ = static_cast<float>(app.getGamma());
        first_frame_ = false;
    }

    // Full window ImGui panel
    ImGuiViewport* viewport = ImGui::GetMainViewport();
    ImGui::SetNextWindowPos(viewport->Pos);
    ImGui::SetNextWindowSize(viewport->Size);

    ImGuiWindowFlags flags =
        ImGuiWindowFlags_NoTitleBar |
        ImGuiWindowFlags_NoResize |
        ImGuiWindowFlags_NoMove |
        ImGuiWindowFlags_NoCollapse |
        ImGuiWindowFlags_NoBringToFrontOnFocus;

    ImGui::Begin("##MainWindow", nullptr, flags);

    // Title
    ImGui::TextUnformatted("Lumos - Gamma Control");
    ImGui::Separator();
    ImGui::Spacing();

    // Gamma slider
    ImGui::TextUnformatted("Gamma");
    ImGui::SetNextItemWidth(-1);
    if (ImGui::SliderFloat("##Gamma", &gamma_slider_, 0.1f, 9.0f, "%.2f")) {
        app.setGamma(static_cast<double>(gamma_slider_));
    }

    ImGui::Spacing();

    // Current value display
    ImGui::Text("Current: %.2f", gamma_slider_);

    ImGui::Spacing();
    ImGui::Spacing();

    // Reset button
    if (ImGui::Button("Reset to Default", ImVec2(-1, 0))) {
        app.resetGamma();
        gamma_slider_ = static_cast<float>(app.getGamma());
    }

    // Hotkey hint
    ImGui::Spacing();
    ImGui::TextDisabled("Hotkeys: Ctrl+Alt+Up/Down, Ctrl+Alt+R");

    // Status at bottom
    ImGui::Spacing();
    ImGui::Separator();
    ImGui::TextDisabled("%s", app.getStatusText());

    ImGui::End();
}

} // namespace lumos::ui
```

**Step 2: Commit UI updates**

Run:

```bash
git add src/ui/main_window.cpp
git commit -m "feat: add hotkey hints to UI"
```

---

## Task 7: Update main.cpp with CLI and Hotkey Handling

**Files:**

- Modify: `src/main.cpp`

**Step 1: Update main.cpp**

Add CLI processing and hotkey message handling to `src/main.cpp`:

At the top, add include:

```cpp
#include "cli.h"
```

At the start of WinMain, after crash handler setup, add CLI processing:

```cpp
    // Parse command line
    lumos::CliArgs cli_args = lumos::Cli::parse(GetCommandLineW());

    switch (cli_args.action) {
    case lumos::CliAction::ShowHelp:
        lumos::Cli::printHelp();
        return 0;

    case lumos::CliAction::ShowVersion:
        lumos::Cli::printVersion();
        return 0;

    case lumos::CliAction::SetGamma:
        {
            lumos::platform::Gamma gamma;
            gamma.initialize();
            gamma.applyAll(cli_args.gamma_value);
            // Don't restore on exit for CLI mode
        }
        return 0;

    case lumos::CliAction::ShowGui:
    default:
        break; // Continue to GUI
    }
```

In WndProc, add hotkey handler:

```cpp
    case WM_HOTKEY:
        if (g_app) {
            g_app->handleHotkeyMessage(wParam);
        }
        return 0;
```

**Step 2: Commit main.cpp updates**

Run:

```bash
git add src/main.cpp
git commit -m "feat: add CLI processing and hotkey handling to main"
```

---

## Task 8: Update CMakeLists.txt with All New Sources

**Files:**

- Modify: `CMakeLists.txt`

**Step 1: Update CMakeLists.txt**

Replace `CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.20)
project(lumos VERSION 0.2.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ImGui
add_subdirectory(third_party/imgui)

# Main executable (WIN32 = no console window)
add_executable(lumos WIN32
    src/main.cpp
    src/app.cpp
    src/cli.cpp
    src/config.cpp
    src/platform/win32/gamma.cpp
    src/platform/win32/hotkeys.cpp
    src/platform/win32/tray.cpp
    src/ui/main_window.cpp
    resources/lumos.rc
)

target_include_directories(lumos PRIVATE src)

target_link_libraries(lumos PRIVATE
    imgui
    dwmapi
)

# Enable warnings
if(MSVC)
    target_compile_options(lumos PRIVATE /W4)
endif()
```

**Step 2: Update version in resource file**

Update `resources/lumos.rc` version strings to 0.2.0.

**Step 3: Commit CMake updates**

Run:

```bash
git add CMakeLists.txt resources/lumos.rc
git commit -m "chore: update CMakeLists.txt for v0.2 with all new modules"
```

---

## Task 9: Update README

**Files:**

- Modify: `README.md`

**Step 1: Update README.md**

Add v0.2 features documentation:

```markdown
# Lumos

Monitor gamma adjustment utility for Windows.

## Features

- System tray application
- Gamma slider (0.1 - 9.0 range)
- Multi-monitor support (applies to all displays)
- Global hotkeys:
  - `Ctrl+Alt+Up` - Increase gamma by 0.1
  - `Ctrl+Alt+Down` - Decrease gamma by 0.1
  - `Ctrl+Alt+R` - Reset to default
- Command line interface
- Remembers last gamma setting
- Crash-safe gamma restoration

## Usage

### GUI Mode

```
lumos
```

Opens the graphical interface.

### CLI Mode

```
lumos 1.2      # Set gamma to 1.2 and exit
lumos --help   # Show help
lumos --version # Show version
```

## Building

Requires:
- CMake 3.20+
- Visual Studio 2022 (or Build Tools)
- Windows SDK 10.0.19041+

```bash
git clone --recursive https://github.com/IanDirkArmstrong/lumos.git
cd lumos
cmake -B build -G "Visual Studio 17 2022"
cmake --build build --config Release
```

## License

GPL v2
```

**Step 2: Commit README updates**

Run:

```bash
git add README.md
git commit -m "docs: update README for v0.2 features"
```

---

## Task 10: Final Testing & Push

**Step 1: Verify build**

Run:

```bash
cmake -B build -G "Visual Studio 17 2022"
cmake --build build --config Release
```

**Step 2: Test CLI**

Run:

```bash
./build/Release/lumos.exe --help
./build/Release/lumos.exe --version
./build/Release/lumos.exe 1.5
```

**Step 3: Test GUI**

- Launch `lumos.exe`
- Verify multi-monitor status shows correct count
- Test hotkeys: Ctrl+Alt+Up, Ctrl+Alt+Down, Ctrl+Alt+R
- Verify tray icon and menu work
- Test window hide/show behavior

**Step 4: Push to GitHub**

Run:

```bash
git push origin main
```

---

## Task 11: About Dialog

**Files:**

- Create: `src/ui/about_dialog.h`
- Create: `src/ui/about_dialog.cpp`
- Modify: `src/ui/main_window.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create about_dialog.h**

Create `src/ui/about_dialog.h`:

```cpp
// Lumos - About dialog
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

namespace lumos::ui {

class AboutDialog {
public:
    AboutDialog() = default;

    // Show the dialog (call each frame when visible)
    void render(bool* p_open);

    // Open the dialog
    void open() { visible_ = true; }

    // Check if visible
    bool isVisible() const { return visible_; }

private:
    bool visible_ = false;
};

} // namespace lumos::ui
```

**Step 2: Create about_dialog.cpp**

Create `src/ui/about_dialog.cpp`:

```cpp
// Lumos - About dialog
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "about_dialog.h"
#include "imgui.h"

namespace lumos::ui {

void AboutDialog::render(bool* p_open)
{
    if (!visible_) return;

    ImGui::SetNextWindowSize(ImVec2(350, 280), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("About Lumos", &visible_, ImGuiWindowFlags_NoResize)) {
        ImGui::TextUnformatted("Lumos v0.2.0");
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextWrapped(
            "A modern C++ reimplementation of Gamminator, "
            "a monitor gamma adjustment utility for Windows.");

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextUnformatted("Attribution:");
        ImGui::BulletText("Original Gamminator by Wolfgang Freiler (2005)");
        ImGui::BulletText("Multi-monitor mod by Lady Eklipse (v0.5.7)");
        ImGui::BulletText("Lumos reimplementation by Ian Dirk Armstrong");

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextUnformatted("License: GPL v2");
        ImGui::TextDisabled("This is free software. You may redistribute copies of it");
        ImGui::TextDisabled("under the terms of the GNU General Public License.");

        ImGui::Spacing();
        ImGui::Spacing();

        if (ImGui::Button("Close", ImVec2(-1, 0))) {
            visible_ = false;
        }
    }
    ImGui::End();

    if (p_open) *p_open = visible_;
}

} // namespace lumos::ui
```

**Step 3: Add About button to main_window.cpp**

In `src/ui/main_window.cpp`, add an "About" button that opens the About dialog.

**Step 4: Update CMakeLists.txt**

Add `src/ui/about_dialog.cpp` to the executable sources.

**Step 5: Commit About dialog**

Run:

```bash
git add src/ui/about_dialog.h src/ui/about_dialog.cpp src/ui/main_window.cpp CMakeLists.txt
git commit -m "feat: add About dialog with proper attribution"
```

---

## Task 12: Help Dialog

**Files:**

- Create: `src/ui/help_dialog.h`
- Create: `src/ui/help_dialog.cpp`
- Modify: `src/ui/main_window.cpp`
- Modify: `CMakeLists.txt`

**Step 1: Create help_dialog.h**

Create `src/ui/help_dialog.h`:

```cpp
// Lumos - Help dialog
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#pragma once

namespace lumos::ui {

class HelpDialog {
public:
    HelpDialog() = default;

    // Show the dialog (call each frame when visible)
    void render(bool* p_open);

    // Open the dialog
    void open() { visible_ = true; }

    // Check if visible
    bool isVisible() const { return visible_; }

private:
    bool visible_ = false;
};

} // namespace lumos::ui
```

**Step 2: Create help_dialog.cpp**

Create `src/ui/help_dialog.cpp`:

```cpp
// Lumos - Help dialog
// Copyright (C) 2026 Ian Dirk Armstrong
// License: GPL v2

#include "help_dialog.h"
#include "imgui.h"

namespace lumos::ui {

void HelpDialog::render(bool* p_open)
{
    if (!visible_) return;

    ImGui::SetNextWindowSize(ImVec2(400, 350), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Lumos Help", &visible_, ImGuiWindowFlags_NoResize)) {
        ImGui::TextUnformatted("Usage");
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextWrapped(
            "Use the slider to adjust your monitor's gamma value. "
            "Gamma affects the brightness and contrast of your display.");

        ImGui::Spacing();
        ImGui::BulletText("Values < 1.0: Darker image");
        ImGui::BulletText("Value = 1.0: Normal (default)");
        ImGui::BulletText("Values > 1.0: Brighter image");

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextUnformatted("Global Hotkeys");
        ImGui::Spacing();

        ImGui::Columns(2, "hotkeys", false);
        ImGui::SetColumnWidth(0, 150);
        ImGui::Text("Ctrl+Alt+Up"); ImGui::NextColumn();
        ImGui::Text("Increase gamma"); ImGui::NextColumn();
        ImGui::Text("Ctrl+Alt+Down"); ImGui::NextColumn();
        ImGui::Text("Decrease gamma"); ImGui::NextColumn();
        ImGui::Text("Ctrl+Alt+R"); ImGui::NextColumn();
        ImGui::Text("Reset to default"); ImGui::NextColumn();
        ImGui::Columns(1);

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        ImGui::TextUnformatted("Command Line");
        ImGui::Spacing();
        ImGui::TextDisabled("lumos              Open the GUI");
        ImGui::TextDisabled("lumos 1.2          Set gamma to 1.2 and exit");
        ImGui::TextDisabled("lumos --help       Show help");
        ImGui::TextDisabled("lumos --version    Show version");

        ImGui::Spacing();
        ImGui::Spacing();

        if (ImGui::Button("Close", ImVec2(-1, 0))) {
            visible_ = false;
        }
    }
    ImGui::End();

    if (p_open) *p_open = visible_;
}

} // namespace lumos::ui
```

**Step 3: Add Help button to main_window.cpp**

In `src/ui/main_window.cpp`, add a "Help" button that opens the Help dialog.

**Step 4: Update CMakeLists.txt**

Add `src/ui/help_dialog.cpp` to the executable sources.

**Step 5: Commit Help dialog**

Run:

```bash
git add src/ui/help_dialog.h src/ui/help_dialog.cpp src/ui/main_window.cpp CMakeLists.txt
git commit -m "feat: add Help dialog with usage instructions"
```

---

## Summary

After completing all tasks, v0.2 will have:

- **Global hotkeys**: Ctrl+Alt+Up/Down/R for gamma adjustment
- **Multi-monitor support**: Applies gamma to all connected displays
- **CLI interface**: `lumos 1.2` sets gamma and exits
- **About dialog**: Version info, attribution to original Gamminator authors, license
- **Help dialog**: Usage instructions, hotkey reference, CLI examples
- **Updated UI**: Shows monitor count, hotkey hints, About and Help buttons

**Next milestone (v0.3 "Polish")** will add:

- Test pattern display (striped black/white)
- Real-time gamma curve visualization
